{
    "docs": [
        {
            "location": "/",
            "text": "zend-text\n\n\n\n\n\n\nZend\\Text\n is a component to work on text strings. It contains the subcomponents:\n\n\n\n\nZend\\Text\\Figlet\n that enables developers to create a so called FIGlet text.\n  A FIGlet text is a string, which is represented as ASCII art. FIGlets use a\n  special font format, called FLT (FigLet Font). By default, one standard font is\n  shipped with \nZend\\Text\\Figlet\n, but you can download additional fonts \nhere\n\n\n\n\nZend\\Text\\Table\n to create text based tables on the fly with different\n  decorators. This can be helpful, if you either want to send structured data in\n  text emails, which are used to have mono-spaced fonts, or to display table\n  information in a CLI application. \nZend\\Text\\Table\n supports multi-line\n  columns, colspan and align as well.\n\n\n\n\n\n\nFile issues at https://github.com/zendframework/zend-text/issues\n\n\n\n\nDocumentation is at https://docs.zendframework.com/zend-text/",
            "title": "zend-text"
        },
        {
            "location": "/#zend-text",
            "text": "Zend\\Text  is a component to work on text strings. It contains the subcomponents:   Zend\\Text\\Figlet  that enables developers to create a so called FIGlet text.\n  A FIGlet text is a string, which is represented as ASCII art. FIGlets use a\n  special font format, called FLT (FigLet Font). By default, one standard font is\n  shipped with  Zend\\Text\\Figlet , but you can download additional fonts  here   Zend\\Text\\Table  to create text based tables on the fly with different\n  decorators. This can be helpful, if you either want to send structured data in\n  text emails, which are used to have mono-spaced fonts, or to display table\n  information in a CLI application.  Zend\\Text\\Table  supports multi-line\n  columns, colspan and align as well.    File issues at https://github.com/zendframework/zend-text/issues   Documentation is at https://docs.zendframework.com/zend-text/",
            "title": "zend-text"
        },
        {
            "location": "/figlet/",
            "text": "Figlets\n\n\nZend\\Text\\Figlet\n is a component which enables developers to create a so called FIGlet text.\nFIGlet text is a string represented as \nASCII\n art.\n\n\nFIGlets use a special font format, called FLT (FigLet Font). By default, one\nstandard font is shipped with \nZend\\Text\\Figlet\n, but you can download\nadditional fonts at \nhttp://www.figlet.org\n.\n\n\n\n\nCompressed fonts\n\n\nZend\\Text\\Figlet\n supports gzipped fonts. This means that you can take an\n\n.flf\n file and gzip it.  To allow \nZend\\Text\\Figlet\n to recognize this, the\ngzipped font must have the extension \n.gz\n.  Further, to be able to use\ngzipped fonts, you have to have enabled the PHP GZIP extension.\n\n\nEncoding\n\n\nZend\\Text\\Figlet\n expects your strings to be UTF-8 encoded by default. If\nthis is not the case, you can supply the character encoding to the second\nparameter to the \nrender()\n method.\n\n\n\n\nYou can define multiple options for a FIGlet. When instantiating\n\nZend\\Text\\Figlet\\Figlet\n, you can supply an array, a \nTraversable\n that\nsupplies both keys and values, or an instance of \nZend\\Config\\Config\n.\n\n\n\n\nfont\n: Defines the font which should be used for rendering. If not defines,\n  the built-in font will be used.\n\n\noutputWidth\n: Defines the maximum width of the output string. This is used\n  for word-wrap as well as justification. Be careful when using small values;\n  they may result in an undefined behaviour. The default value is 80.\n\n\nhandleParagraphs\n: A boolean which indicates how new lines are handled. When\n  set to \nTRUE\n, single new lines are ignored and instead treated as single\n  spaces; only multiple new lines will be handled as such. The default value is\n  \nFALSE\n.\n\n\njustification\n: May be one of the \nZend\\Text\\Figlet\\Figlet::JUSTIFICATION_*\n\n  constants, which include \nJUSTIFICATION_LEFT\n, \nJUSTIFICATION_CENTER\n, and\n  \nJUSTIFICATION_RIGHT\n The default justification is defined by the\n  \nrightToLeft\n value.\n\n\nrightToLeft\n: Defines the direction in which text is written. May be either\n  \nZend\\Text\\Figlet\\Figlet::DIRECTION_LEFT_TO_RIGHT\n or\n  \nZend\\Text\\Figlet\\Figlet::DIRECTION_RIGHT_TO_LEFT\n. By default, the setting of\n  the font file is used.  When justification is not defined, a text written from\n  right-to-left is automatically right-aligned.\n\n\nsmushMode\n: An integer bitfield which defines how single characters are\n  smushed together; can be the sum of multiple values from\n  \nZend\\Text\\Figlet\\Figlet::SM_*\n. The component defines the following smush\n  modes: \nSM_EQUAL\n, \nSM_LOWLINE\n, \nSM_HIERARCHY\n, \nSM_PAIR\n, \nSM_BIGX\n,\n  \nSM_HARDBLANK\n, \nSM_KERN\n, and \nSM_SMUSH\n. A value of 0 doesn't disable the\n  entire smushing, but forces \nSM_KERN\n to be applied, while a value of -1\n  disables it. An explanation of the different smush modes can be found\n  \nhere\n. By default the setting of the\n  font file is used. The smush mode option is normally used only by font\n  designers testing the various layoutmodes with a new font.\n\n\n\n\nBasic Usage\n\n\n$figlet = new Zend\\Text\\Figlet\\Figlet();\necho $figlet->render('Zend');\n\n\n\nAssuming you are using a monospace font, the above results in the following:\n\n\n  ______    ______    _  __   ______\n |__  //   |  ___||  | \\| || |  __ \\\\\n   / //    | ||__    |  ' || | |  \\ ||\n  / //__   | ||___   | .  || | |__/ ||\n /_____||  |_____||  |_|\\_|| |_____//\n `-----`'  `-----`   `-` -`'  -----`",
            "title": "Figlets"
        },
        {
            "location": "/figlet/#figlets",
            "text": "Zend\\Text\\Figlet  is a component which enables developers to create a so called FIGlet text.\nFIGlet text is a string represented as  ASCII  art.  FIGlets use a special font format, called FLT (FigLet Font). By default, one\nstandard font is shipped with  Zend\\Text\\Figlet , but you can download\nadditional fonts at  http://www.figlet.org .",
            "title": "Figlets"
        },
        {
            "location": "/figlet/#compressed-fonts",
            "text": "Zend\\Text\\Figlet  supports gzipped fonts. This means that you can take an .flf  file and gzip it.  To allow  Zend\\Text\\Figlet  to recognize this, the\ngzipped font must have the extension  .gz .  Further, to be able to use\ngzipped fonts, you have to have enabled the PHP GZIP extension.",
            "title": "Compressed fonts"
        },
        {
            "location": "/figlet/#encoding",
            "text": "Zend\\Text\\Figlet  expects your strings to be UTF-8 encoded by default. If\nthis is not the case, you can supply the character encoding to the second\nparameter to the  render()  method.   You can define multiple options for a FIGlet. When instantiating Zend\\Text\\Figlet\\Figlet , you can supply an array, a  Traversable  that\nsupplies both keys and values, or an instance of  Zend\\Config\\Config .   font : Defines the font which should be used for rendering. If not defines,\n  the built-in font will be used.  outputWidth : Defines the maximum width of the output string. This is used\n  for word-wrap as well as justification. Be careful when using small values;\n  they may result in an undefined behaviour. The default value is 80.  handleParagraphs : A boolean which indicates how new lines are handled. When\n  set to  TRUE , single new lines are ignored and instead treated as single\n  spaces; only multiple new lines will be handled as such. The default value is\n   FALSE .  justification : May be one of the  Zend\\Text\\Figlet\\Figlet::JUSTIFICATION_* \n  constants, which include  JUSTIFICATION_LEFT ,  JUSTIFICATION_CENTER , and\n   JUSTIFICATION_RIGHT  The default justification is defined by the\n   rightToLeft  value.  rightToLeft : Defines the direction in which text is written. May be either\n   Zend\\Text\\Figlet\\Figlet::DIRECTION_LEFT_TO_RIGHT  or\n   Zend\\Text\\Figlet\\Figlet::DIRECTION_RIGHT_TO_LEFT . By default, the setting of\n  the font file is used.  When justification is not defined, a text written from\n  right-to-left is automatically right-aligned.  smushMode : An integer bitfield which defines how single characters are\n  smushed together; can be the sum of multiple values from\n   Zend\\Text\\Figlet\\Figlet::SM_* . The component defines the following smush\n  modes:  SM_EQUAL ,  SM_LOWLINE ,  SM_HIERARCHY ,  SM_PAIR ,  SM_BIGX ,\n   SM_HARDBLANK ,  SM_KERN , and  SM_SMUSH . A value of 0 doesn't disable the\n  entire smushing, but forces  SM_KERN  to be applied, while a value of -1\n  disables it. An explanation of the different smush modes can be found\n   here . By default the setting of the\n  font file is used. The smush mode option is normally used only by font\n  designers testing the various layoutmodes with a new font.",
            "title": "Encoding"
        },
        {
            "location": "/figlet/#basic-usage",
            "text": "$figlet = new Zend\\Text\\Figlet\\Figlet();\necho $figlet->render('Zend');  Assuming you are using a monospace font, the above results in the following:    ______    ______    _  __   ______\n |__  //   |  ___||  | \\| || |  __ \\\\\n   / //    | ||__    |  ' || | |  \\ ||\n  / //__   | ||___   | .  || | |__/ ||\n /_____||  |_____||  |_|\\_|| |_____//\n `-----`'  `-----`   `-` -`'  -----`",
            "title": "Basic Usage"
        },
        {
            "location": "/table/",
            "text": "Tables\n\n\nZend\\Text\\Table\n is a component for creating text-based tables on the fly using\ndecorators.  This can be helpful for sending structured data in text emails, or\nto display table information in a CLI application. \nZend\\Text\\Table\n supports\nmulti-line columns, column spans, and alignment.\n\n\n\n\nEncoding\n\n\nZend\\Text\\Table\n expects your strings to be UTF-8 encoded by default. If this\nis not the case, you can either supply the character encoding as a parameter\nto the constructor or the \nsetContent()\n method of \nZend\\Text\\Table\\Column\n.\nAlternately, if you have a different encoding in the entire process, you can\ndefine the standard input charset with\n\nZend\\Text\\Table\\Table::setInputCharset($charset)\n. In case you need another\noutput charset for the table, you can set it with\n\nZend\\Text\\Table\\Table::setOutputCharset($charset)\n.\n\n\n\n\nA \nZend\\Text\\Table\\Table\n object consists of rows which contain columns,\nrepresented by \nZend\\Text\\Table\\Row\n and \nZend\\Text\\Table\\Column\n, respectively.\nWhen creating a table, you can supply an array with options for the table.\n\n\nOptions include:\n\n\n\n\ncolumnWidths\n (required): An array defining all columns width their widths in characters.\n\n\ndecorator\n: The decorator to use for the table borders. The default is\n  \nunicode\n, but you may also specify \nascii\n or give an instance of a custom\n  decorator object.\n\n\npadding\n: The number of characters of left and right padding within the\n  columns. The default padding is zero.\n\n\nAutoSeparate\n: How the rows are separated with horizontal lines; the default\n  is to separate all rows. This is defined as a bitmask containing one ore more\n  of the following \nZend\\Text\\Table\n constants:\n\n\nZend\\Text\\Table\\Table::AUTO_SEPARATE_NONE\n\n\nZend\\Text\\Table\\Table::AUTO_SEPARATE_HEADER\n\n\nZend\\Text\\Table\\Table::AUTO_SEPARATE_FOOTER\n\n\nZend\\Text\\Table\\Table::AUTO_SEPARATE_ALL\n\n  Where header is always the first row, and the footer is always the last row.\n\n\n\n\nRows are added to the table by creating a new instance of \nZend\\Text\\Table\\Row\n\nand appending it to the table via the \nappendRow()\n method. Rows themselves have\nno options. You can also provide the \nappendRow()\n method with an array of\noptions describing a row; these will then be automatically converted to a row\nobject, containing multiple column objects.\n\n\nAdding columns follows the same process as adding rows.  Create a new instance\nof \nZend\\Text\\Table\\Column\n and then either set the column options in the\nconstructor or later with the \nset*()\n methods. The first parameter is the\ncontent of the column; content may have multiple lines, which should be\nseparated by \n\\n\n characters. The second parameter defines the alignment, which\nis 'left' by default, but can be any of the following \nZend\\Text\\Table\\Column\n\nconstant values:\n\n\n\n\nALIGN_LEFT\n\n\nALIGN_CENTER\n\n\nALIGN_RIGHT\n\n\n\n\nThe third parameter is the column span. For example, when you provide the value \"2\", the\ncolumn will span two columns of the table.\n\n\nThe last parameter defines the encoding of the content, which should be\nsupplied only if the content is neither ASCII nor UTF-8.\n\n\nTo append the column to the row, call \nappendColumn()\n in your row object with\nthe column object as a parameter. Alternately, provide a string to the\n\nappendColumn()\n method.\n\n\nTo render the table, use the \nrender()\n method, or rely on the\n\n__toString()\n implementation to do implicit casting\n\n\necho $table;\n\n// or\n$tableString = (string) $table`;\n\n\n\nBasic Usage\n\n\n$table = new Zend\\Text\\Table\\Table([\n    'columnWidths' => [10, 20]\n]);\n\n// Implicitly build rows, by supply an array of column values:\n$table->appendRow(['Zend', 'Framework']);\n\n// Or build the row and column manually:\n$row = new Zend\\Text\\Table\\Row();\n\n$row->appendColumn(new Zend\\Text\\Table\\Column('Zend'));\n$row->appendColumn(new Zend\\Text\\Table\\Column('Framework'));\n\n$table->appendRow($row);\n\necho $table;\n\n\n\nThe above results in the following output:\n\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Zend      \u2502Framework           \u2502\n|\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500|\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500|\n\u2502Zend      \u2502Framework           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
            "title": "Tables"
        },
        {
            "location": "/table/#tables",
            "text": "Zend\\Text\\Table  is a component for creating text-based tables on the fly using\ndecorators.  This can be helpful for sending structured data in text emails, or\nto display table information in a CLI application.  Zend\\Text\\Table  supports\nmulti-line columns, column spans, and alignment.",
            "title": "Tables"
        },
        {
            "location": "/table/#encoding",
            "text": "Zend\\Text\\Table  expects your strings to be UTF-8 encoded by default. If this\nis not the case, you can either supply the character encoding as a parameter\nto the constructor or the  setContent()  method of  Zend\\Text\\Table\\Column .\nAlternately, if you have a different encoding in the entire process, you can\ndefine the standard input charset with Zend\\Text\\Table\\Table::setInputCharset($charset) . In case you need another\noutput charset for the table, you can set it with Zend\\Text\\Table\\Table::setOutputCharset($charset) .   A  Zend\\Text\\Table\\Table  object consists of rows which contain columns,\nrepresented by  Zend\\Text\\Table\\Row  and  Zend\\Text\\Table\\Column , respectively.\nWhen creating a table, you can supply an array with options for the table.  Options include:   columnWidths  (required): An array defining all columns width their widths in characters.  decorator : The decorator to use for the table borders. The default is\n   unicode , but you may also specify  ascii  or give an instance of a custom\n  decorator object.  padding : The number of characters of left and right padding within the\n  columns. The default padding is zero.  AutoSeparate : How the rows are separated with horizontal lines; the default\n  is to separate all rows. This is defined as a bitmask containing one ore more\n  of the following  Zend\\Text\\Table  constants:  Zend\\Text\\Table\\Table::AUTO_SEPARATE_NONE  Zend\\Text\\Table\\Table::AUTO_SEPARATE_HEADER  Zend\\Text\\Table\\Table::AUTO_SEPARATE_FOOTER  Zend\\Text\\Table\\Table::AUTO_SEPARATE_ALL \n  Where header is always the first row, and the footer is always the last row.   Rows are added to the table by creating a new instance of  Zend\\Text\\Table\\Row \nand appending it to the table via the  appendRow()  method. Rows themselves have\nno options. You can also provide the  appendRow()  method with an array of\noptions describing a row; these will then be automatically converted to a row\nobject, containing multiple column objects.  Adding columns follows the same process as adding rows.  Create a new instance\nof  Zend\\Text\\Table\\Column  and then either set the column options in the\nconstructor or later with the  set*()  methods. The first parameter is the\ncontent of the column; content may have multiple lines, which should be\nseparated by  \\n  characters. The second parameter defines the alignment, which\nis 'left' by default, but can be any of the following  Zend\\Text\\Table\\Column \nconstant values:   ALIGN_LEFT  ALIGN_CENTER  ALIGN_RIGHT   The third parameter is the column span. For example, when you provide the value \"2\", the\ncolumn will span two columns of the table.  The last parameter defines the encoding of the content, which should be\nsupplied only if the content is neither ASCII nor UTF-8.  To append the column to the row, call  appendColumn()  in your row object with\nthe column object as a parameter. Alternately, provide a string to the appendColumn()  method.  To render the table, use the  render()  method, or rely on the __toString()  implementation to do implicit casting  echo $table;\n\n// or\n$tableString = (string) $table`;",
            "title": "Encoding"
        },
        {
            "location": "/table/#basic-usage",
            "text": "$table = new Zend\\Text\\Table\\Table([\n    'columnWidths' => [10, 20]\n]);\n\n// Implicitly build rows, by supply an array of column values:\n$table->appendRow(['Zend', 'Framework']);\n\n// Or build the row and column manually:\n$row = new Zend\\Text\\Table\\Row();\n\n$row->appendColumn(new Zend\\Text\\Table\\Column('Zend'));\n$row->appendColumn(new Zend\\Text\\Table\\Column('Framework'));\n\n$table->appendRow($row);\n\necho $table;  The above results in the following output:  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Zend      \u2502Framework           \u2502\n|\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500|\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500|\n\u2502Zend      \u2502Framework           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
            "title": "Basic Usage"
        }
    ]
}